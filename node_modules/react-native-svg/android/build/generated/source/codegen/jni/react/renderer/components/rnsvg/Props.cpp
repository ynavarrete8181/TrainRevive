
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsCpp.js
 */

#include <react/renderer/components/rnsvg/Props.h>
#include <folly/dynamic.h>
#include <react/renderer/components/image/conversions.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>

namespace facebook::react {

RNSVGSvgViewAndroidProps::RNSVGSvgViewAndroidProps(
    const PropsParserContext &context,
    const RNSVGSvgViewAndroidProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    bbWidth(convertRawProp(context, rawProps, "bbWidth", sourceProps.bbWidth, {})),
    bbHeight(convertRawProp(context, rawProps, "bbHeight", sourceProps.bbHeight, {})),
    minX(convertRawProp(context, rawProps, "minX", sourceProps.minX, {0.0})),
    minY(convertRawProp(context, rawProps, "minY", sourceProps.minY, {0.0})),
    vbWidth(convertRawProp(context, rawProps, "vbWidth", sourceProps.vbWidth, {0.0})),
    vbHeight(convertRawProp(context, rawProps, "vbHeight", sourceProps.vbHeight, {0.0})),
    align(convertRawProp(context, rawProps, "align", sourceProps.align, {})),
    meetOrSlice(convertRawProp(context, rawProps, "meetOrSlice", sourceProps.meetOrSlice, {0})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    hasTVPreferredFocus(convertRawProp(context, rawProps, "hasTVPreferredFocus", sourceProps.hasTVPreferredFocus, {false})),
    borderBottomColor(convertRawProp(context, rawProps, "borderBottomColor", sourceProps.borderBottomColor, {})),
    nextFocusDown(convertRawProp(context, rawProps, "nextFocusDown", sourceProps.nextFocusDown, {0})),
    borderRightColor(convertRawProp(context, rawProps, "borderRightColor", sourceProps.borderRightColor, {})),
    nextFocusRight(convertRawProp(context, rawProps, "nextFocusRight", sourceProps.nextFocusRight, {0})),
    borderLeftColor(convertRawProp(context, rawProps, "borderLeftColor", sourceProps.borderLeftColor, {})),
    borderColor(convertRawProp(context, rawProps, "borderColor", sourceProps.borderColor, {})),
    removeClippedSubviews(convertRawProp(context, rawProps, "removeClippedSubviews", sourceProps.removeClippedSubviews, {false})),
    nextFocusForward(convertRawProp(context, rawProps, "nextFocusForward", sourceProps.nextFocusForward, {0})),
    nextFocusUp(convertRawProp(context, rawProps, "nextFocusUp", sourceProps.nextFocusUp, {0})),
    accessible(convertRawProp(context, rawProps, "accessible", sourceProps.accessible, {false})),
    borderStartColor(convertRawProp(context, rawProps, "borderStartColor", sourceProps.borderStartColor, {})),
    borderEndColor(convertRawProp(context, rawProps, "borderEndColor", sourceProps.borderEndColor, {})),
    focusable(convertRawProp(context, rawProps, "focusable", sourceProps.focusable, {false})),
    nativeBackgroundAndroid(convertRawProp(context, rawProps, "nativeBackgroundAndroid", sourceProps.nativeBackgroundAndroid, {})),
    nativeForegroundAndroid(convertRawProp(context, rawProps, "nativeForegroundAndroid", sourceProps.nativeForegroundAndroid, {})),
    backfaceVisibility(convertRawProp(context, rawProps, "backfaceVisibility", sourceProps.backfaceVisibility, {})),
    borderStyle(convertRawProp(context, rawProps, "borderStyle", sourceProps.borderStyle, {})),
    needsOffscreenAlphaCompositing(convertRawProp(context, rawProps, "needsOffscreenAlphaCompositing", sourceProps.needsOffscreenAlphaCompositing, {false})),
    hitSlop(convertRawProp(context, rawProps, "hitSlop", sourceProps.hitSlop, {})),
    borderTopColor(convertRawProp(context, rawProps, "borderTopColor", sourceProps.borderTopColor, {})),
    nextFocusLeft(convertRawProp(context, rawProps, "nextFocusLeft", sourceProps.nextFocusLeft, {0})),
    borderBlockColor(convertRawProp(context, rawProps, "borderBlockColor", sourceProps.borderBlockColor, {})),
    borderBlockEndColor(convertRawProp(context, rawProps, "borderBlockEndColor", sourceProps.borderBlockEndColor, {})),
    borderBlockStartColor(convertRawProp(context, rawProps, "borderBlockStartColor", sourceProps.borderBlockStartColor, {})),
    borderRadius(convertRawProp(context, rawProps, "borderRadius", sourceProps.borderRadius, {})),
    borderTopLeftRadius(convertRawProp(context, rawProps, "borderTopLeftRadius", sourceProps.borderTopLeftRadius, {})),
    borderTopRightRadius(convertRawProp(context, rawProps, "borderTopRightRadius", sourceProps.borderTopRightRadius, {})),
    borderBottomRightRadius(convertRawProp(context, rawProps, "borderBottomRightRadius", sourceProps.borderBottomRightRadius, {})),
    borderBottomLeftRadius(convertRawProp(context, rawProps, "borderBottomLeftRadius", sourceProps.borderBottomLeftRadius, {})),
    borderTopStartRadius(convertRawProp(context, rawProps, "borderTopStartRadius", sourceProps.borderTopStartRadius, {})),
    borderTopEndRadius(convertRawProp(context, rawProps, "borderTopEndRadius", sourceProps.borderTopEndRadius, {})),
    borderBottomStartRadius(convertRawProp(context, rawProps, "borderBottomStartRadius", sourceProps.borderBottomStartRadius, {})),
    borderBottomEndRadius(convertRawProp(context, rawProps, "borderBottomEndRadius", sourceProps.borderBottomEndRadius, {})),
    borderEndEndRadius(convertRawProp(context, rawProps, "borderEndEndRadius", sourceProps.borderEndEndRadius, {})),
    borderEndStartRadius(convertRawProp(context, rawProps, "borderEndStartRadius", sourceProps.borderEndStartRadius, {})),
    borderStartEndRadius(convertRawProp(context, rawProps, "borderStartEndRadius", sourceProps.borderStartEndRadius, {})),
    borderStartStartRadius(convertRawProp(context, rawProps, "borderStartStartRadius", sourceProps.borderStartStartRadius, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGSvgViewAndroidProps::getDiffPropsImplementationTarget() const {
  return "RNSVGSvgViewAndroid";
}

folly::dynamic RNSVGSvgViewAndroidProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGSvgViewAndroidProps();
  const RNSVGSvgViewAndroidProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGSvgViewAndroidProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (bbWidth != oldProps->bbWidth) {
    result["bbWidth"] = bbWidth;
  }
    
  if (bbHeight != oldProps->bbHeight) {
    result["bbHeight"] = bbHeight;
  }
    
  if ((minX != oldProps->minX) && !(std::isnan(minX) && std::isnan(oldProps->minX))) {
    result["minX"] = minX;
  }
    
  if ((minY != oldProps->minY) && !(std::isnan(minY) && std::isnan(oldProps->minY))) {
    result["minY"] = minY;
  }
    
  if ((vbWidth != oldProps->vbWidth) && !(std::isnan(vbWidth) && std::isnan(oldProps->vbWidth))) {
    result["vbWidth"] = vbWidth;
  }
    
  if ((vbHeight != oldProps->vbHeight) && !(std::isnan(vbHeight) && std::isnan(oldProps->vbHeight))) {
    result["vbHeight"] = vbHeight;
  }
    
  if (align != oldProps->align) {
    result["align"] = align;
  }
    
  if (meetOrSlice != oldProps->meetOrSlice) {
    result["meetOrSlice"] = meetOrSlice;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (hasTVPreferredFocus != oldProps->hasTVPreferredFocus) {
    result["hasTVPreferredFocus"] = hasTVPreferredFocus;
  }
    
  if (borderBottomColor != oldProps->borderBottomColor) {
    result["borderBottomColor"] = *borderBottomColor;
  }
    
  if (nextFocusDown != oldProps->nextFocusDown) {
    result["nextFocusDown"] = nextFocusDown;
  }
    
  if (borderRightColor != oldProps->borderRightColor) {
    result["borderRightColor"] = *borderRightColor;
  }
    
  if (nextFocusRight != oldProps->nextFocusRight) {
    result["nextFocusRight"] = nextFocusRight;
  }
    
  if (borderLeftColor != oldProps->borderLeftColor) {
    result["borderLeftColor"] = *borderLeftColor;
  }
    
  if (borderColor != oldProps->borderColor) {
    result["borderColor"] = *borderColor;
  }
    
  if (removeClippedSubviews != oldProps->removeClippedSubviews) {
    result["removeClippedSubviews"] = removeClippedSubviews;
  }
    
  if (nextFocusForward != oldProps->nextFocusForward) {
    result["nextFocusForward"] = nextFocusForward;
  }
    
  if (nextFocusUp != oldProps->nextFocusUp) {
    result["nextFocusUp"] = nextFocusUp;
  }
    
  if (accessible != oldProps->accessible) {
    result["accessible"] = accessible;
  }
    
  if (borderStartColor != oldProps->borderStartColor) {
    result["borderStartColor"] = *borderStartColor;
  }
    
  if (borderEndColor != oldProps->borderEndColor) {
    result["borderEndColor"] = *borderEndColor;
  }
    
  if (focusable != oldProps->focusable) {
    result["focusable"] = focusable;
  }
    
  if (nativeBackgroundAndroid != oldProps->nativeBackgroundAndroid) {
    result["nativeBackgroundAndroid"] = toDynamic(nativeBackgroundAndroid);
  }
    
  if (nativeForegroundAndroid != oldProps->nativeForegroundAndroid) {
    result["nativeForegroundAndroid"] = toDynamic(nativeForegroundAndroid);
  }
    
  if (backfaceVisibility != oldProps->backfaceVisibility) {
    result["backfaceVisibility"] = backfaceVisibility;
  }
    
  if (borderStyle != oldProps->borderStyle) {
    result["borderStyle"] = borderStyle;
  }
    
  if (needsOffscreenAlphaCompositing != oldProps->needsOffscreenAlphaCompositing) {
    result["needsOffscreenAlphaCompositing"] = needsOffscreenAlphaCompositing;
  }
    
  if (hitSlop != oldProps->hitSlop) {
    result["hitSlop"] = hitSlop;
  }
    
  if (borderTopColor != oldProps->borderTopColor) {
    result["borderTopColor"] = *borderTopColor;
  }
    
  if (nextFocusLeft != oldProps->nextFocusLeft) {
    result["nextFocusLeft"] = nextFocusLeft;
  }
    
  if (borderBlockColor != oldProps->borderBlockColor) {
    result["borderBlockColor"] = *borderBlockColor;
  }
    
  if (borderBlockEndColor != oldProps->borderBlockEndColor) {
    result["borderBlockEndColor"] = *borderBlockEndColor;
  }
    
  if (borderBlockStartColor != oldProps->borderBlockStartColor) {
    result["borderBlockStartColor"] = *borderBlockStartColor;
  }
    
  if (borderRadius != oldProps->borderRadius) {
    result["borderRadius"] = borderRadius;
  }
    
  if (borderTopLeftRadius != oldProps->borderTopLeftRadius) {
    result["borderTopLeftRadius"] = borderTopLeftRadius;
  }
    
  if (borderTopRightRadius != oldProps->borderTopRightRadius) {
    result["borderTopRightRadius"] = borderTopRightRadius;
  }
    
  if (borderBottomRightRadius != oldProps->borderBottomRightRadius) {
    result["borderBottomRightRadius"] = borderBottomRightRadius;
  }
    
  if (borderBottomLeftRadius != oldProps->borderBottomLeftRadius) {
    result["borderBottomLeftRadius"] = borderBottomLeftRadius;
  }
    
  if (borderTopStartRadius != oldProps->borderTopStartRadius) {
    result["borderTopStartRadius"] = borderTopStartRadius;
  }
    
  if (borderTopEndRadius != oldProps->borderTopEndRadius) {
    result["borderTopEndRadius"] = borderTopEndRadius;
  }
    
  if (borderBottomStartRadius != oldProps->borderBottomStartRadius) {
    result["borderBottomStartRadius"] = borderBottomStartRadius;
  }
    
  if (borderBottomEndRadius != oldProps->borderBottomEndRadius) {
    result["borderBottomEndRadius"] = borderBottomEndRadius;
  }
    
  if (borderEndEndRadius != oldProps->borderEndEndRadius) {
    result["borderEndEndRadius"] = borderEndEndRadius;
  }
    
  if (borderEndStartRadius != oldProps->borderEndStartRadius) {
    result["borderEndStartRadius"] = borderEndStartRadius;
  }
    
  if (borderStartEndRadius != oldProps->borderStartEndRadius) {
    result["borderStartEndRadius"] = borderStartEndRadius;
  }
    
  if (borderStartStartRadius != oldProps->borderStartStartRadius) {
    result["borderStartStartRadius"] = borderStartStartRadius;
  }
  return result;
}
#endif
RNSVGCircleProps::RNSVGCircleProps(
    const PropsParserContext &context,
    const RNSVGCircleProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    cx(convertRawProp(context, rawProps, "cx", sourceProps.cx, {})),
    cy(convertRawProp(context, rawProps, "cy", sourceProps.cy, {})),
    r(convertRawProp(context, rawProps, "r", sourceProps.r, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGCircleProps::getDiffPropsImplementationTarget() const {
  return "RNSVGCircle";
}

folly::dynamic RNSVGCircleProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGCircleProps();
  const RNSVGCircleProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGCircleProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (cx != oldProps->cx) {
    result["cx"] = cx;
  }
    
  if (cy != oldProps->cy) {
    result["cy"] = cy;
  }
    
  if (r != oldProps->r) {
    result["r"] = r;
  }
  return result;
}
#endif
RNSVGClipPathProps::RNSVGClipPathProps(
    const PropsParserContext &context,
    const RNSVGClipPathProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGClipPathProps::getDiffPropsImplementationTarget() const {
  return "RNSVGClipPath";
}

folly::dynamic RNSVGClipPathProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGClipPathProps();
  const RNSVGClipPathProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGClipPathProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
  return result;
}
#endif
RNSVGDefsProps::RNSVGDefsProps(
    const PropsParserContext &context,
    const RNSVGDefsProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGDefsProps::getDiffPropsImplementationTarget() const {
  return "RNSVGDefs";
}

folly::dynamic RNSVGDefsProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGDefsProps();
  const RNSVGDefsProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGDefsProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
  return result;
}
#endif
RNSVGEllipseProps::RNSVGEllipseProps(
    const PropsParserContext &context,
    const RNSVGEllipseProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    cx(convertRawProp(context, rawProps, "cx", sourceProps.cx, {})),
    cy(convertRawProp(context, rawProps, "cy", sourceProps.cy, {})),
    rx(convertRawProp(context, rawProps, "rx", sourceProps.rx, {})),
    ry(convertRawProp(context, rawProps, "ry", sourceProps.ry, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGEllipseProps::getDiffPropsImplementationTarget() const {
  return "RNSVGEllipse";
}

folly::dynamic RNSVGEllipseProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGEllipseProps();
  const RNSVGEllipseProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGEllipseProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (cx != oldProps->cx) {
    result["cx"] = cx;
  }
    
  if (cy != oldProps->cy) {
    result["cy"] = cy;
  }
    
  if (rx != oldProps->rx) {
    result["rx"] = rx;
  }
    
  if (ry != oldProps->ry) {
    result["ry"] = ry;
  }
  return result;
}
#endif
RNSVGFeBlendProps::RNSVGFeBlendProps(
    const PropsParserContext &context,
    const RNSVGFeBlendProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    result(convertRawProp(context, rawProps, "result", sourceProps.result, {})),
    in1(convertRawProp(context, rawProps, "in1", sourceProps.in1, {})),
    in2(convertRawProp(context, rawProps, "in2", sourceProps.in2, {})),
    mode(convertRawProp(context, rawProps, "mode", sourceProps.mode, {RNSVGFeBlendMode::Normal})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGFeBlendProps::getDiffPropsImplementationTarget() const {
  return "RNSVGFeBlend";
}

folly::dynamic RNSVGFeBlendProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGFeBlendProps();
  const RNSVGFeBlendProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGFeBlendProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (result != oldProps->result) {
    result["result"] = result;
  }
    
  if (in1 != oldProps->in1) {
    result["in1"] = in1;
  }
    
  if (in2 != oldProps->in2) {
    result["in2"] = in2;
  }
    
  if (mode != oldProps->mode) {
    result["mode"] = toDynamic(mode);
  }
  return result;
}
#endif
RNSVGFeColorMatrixProps::RNSVGFeColorMatrixProps(
    const PropsParserContext &context,
    const RNSVGFeColorMatrixProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    result(convertRawProp(context, rawProps, "result", sourceProps.result, {})),
    in1(convertRawProp(context, rawProps, "in1", sourceProps.in1, {})),
    type(convertRawProp(context, rawProps, "type", sourceProps.type, {RNSVGFeColorMatrixType::Matrix})),
    values(convertRawProp(context, rawProps, "values", sourceProps.values, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGFeColorMatrixProps::getDiffPropsImplementationTarget() const {
  return "RNSVGFeColorMatrix";
}

folly::dynamic RNSVGFeColorMatrixProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGFeColorMatrixProps();
  const RNSVGFeColorMatrixProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGFeColorMatrixProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (result != oldProps->result) {
    result["result"] = result;
  }
    
  if (in1 != oldProps->in1) {
    result["in1"] = in1;
  }
    
  if (type != oldProps->type) {
    result["type"] = toDynamic(type);
  }
    
  if (values != oldProps->values) {
    result["values"] = toDynamic(values);
  }
  return result;
}
#endif
RNSVGFeCompositeProps::RNSVGFeCompositeProps(
    const PropsParserContext &context,
    const RNSVGFeCompositeProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    result(convertRawProp(context, rawProps, "result", sourceProps.result, {})),
    in1(convertRawProp(context, rawProps, "in1", sourceProps.in1, {})),
    in2(convertRawProp(context, rawProps, "in2", sourceProps.in2, {})),
    operator1(convertRawProp(context, rawProps, "operator1", sourceProps.operator1, {RNSVGFeCompositeOperator1::Over})),
    k1(convertRawProp(context, rawProps, "k1", sourceProps.k1, {0.0})),
    k2(convertRawProp(context, rawProps, "k2", sourceProps.k2, {0.0})),
    k3(convertRawProp(context, rawProps, "k3", sourceProps.k3, {0.0})),
    k4(convertRawProp(context, rawProps, "k4", sourceProps.k4, {0.0})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGFeCompositeProps::getDiffPropsImplementationTarget() const {
  return "RNSVGFeComposite";
}

folly::dynamic RNSVGFeCompositeProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGFeCompositeProps();
  const RNSVGFeCompositeProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGFeCompositeProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (result != oldProps->result) {
    result["result"] = result;
  }
    
  if (in1 != oldProps->in1) {
    result["in1"] = in1;
  }
    
  if (in2 != oldProps->in2) {
    result["in2"] = in2;
  }
    
  if (operator1 != oldProps->operator1) {
    result["operator1"] = toDynamic(operator1);
  }
    
  if ((k1 != oldProps->k1) && !(std::isnan(k1) && std::isnan(oldProps->k1))) {
    result["k1"] = k1;
  }
    
  if ((k2 != oldProps->k2) && !(std::isnan(k2) && std::isnan(oldProps->k2))) {
    result["k2"] = k2;
  }
    
  if ((k3 != oldProps->k3) && !(std::isnan(k3) && std::isnan(oldProps->k3))) {
    result["k3"] = k3;
  }
    
  if ((k4 != oldProps->k4) && !(std::isnan(k4) && std::isnan(oldProps->k4))) {
    result["k4"] = k4;
  }
  return result;
}
#endif
RNSVGFeFloodProps::RNSVGFeFloodProps(
    const PropsParserContext &context,
    const RNSVGFeFloodProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    result(convertRawProp(context, rawProps, "result", sourceProps.result, {})),
    floodColor(convertRawProp(context, rawProps, "floodColor", sourceProps.floodColor, {})),
    floodOpacity(convertRawProp(context, rawProps, "floodOpacity", sourceProps.floodOpacity, {1.0})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGFeFloodProps::getDiffPropsImplementationTarget() const {
  return "RNSVGFeFlood";
}

folly::dynamic RNSVGFeFloodProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGFeFloodProps();
  const RNSVGFeFloodProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGFeFloodProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (result != oldProps->result) {
    result["result"] = result;
  }
    
  if (floodColor != oldProps->floodColor) {
    result["floodColor"] = floodColor;
  }
    
  if ((floodOpacity != oldProps->floodOpacity) && !(std::isnan(floodOpacity) && std::isnan(oldProps->floodOpacity))) {
    result["floodOpacity"] = floodOpacity;
  }
  return result;
}
#endif
RNSVGFeGaussianBlurProps::RNSVGFeGaussianBlurProps(
    const PropsParserContext &context,
    const RNSVGFeGaussianBlurProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    result(convertRawProp(context, rawProps, "result", sourceProps.result, {})),
    in1(convertRawProp(context, rawProps, "in1", sourceProps.in1, {})),
    stdDeviationX(convertRawProp(context, rawProps, "stdDeviationX", sourceProps.stdDeviationX, {0.0})),
    stdDeviationY(convertRawProp(context, rawProps, "stdDeviationY", sourceProps.stdDeviationY, {0.0})),
    edgeMode(convertRawProp(context, rawProps, "edgeMode", sourceProps.edgeMode, {RNSVGFeGaussianBlurEdgeMode::None})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGFeGaussianBlurProps::getDiffPropsImplementationTarget() const {
  return "RNSVGFeGaussianBlur";
}

folly::dynamic RNSVGFeGaussianBlurProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGFeGaussianBlurProps();
  const RNSVGFeGaussianBlurProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGFeGaussianBlurProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (result != oldProps->result) {
    result["result"] = result;
  }
    
  if (in1 != oldProps->in1) {
    result["in1"] = in1;
  }
    
  if ((stdDeviationX != oldProps->stdDeviationX) && !(std::isnan(stdDeviationX) && std::isnan(oldProps->stdDeviationX))) {
    result["stdDeviationX"] = stdDeviationX;
  }
    
  if ((stdDeviationY != oldProps->stdDeviationY) && !(std::isnan(stdDeviationY) && std::isnan(oldProps->stdDeviationY))) {
    result["stdDeviationY"] = stdDeviationY;
  }
    
  if (edgeMode != oldProps->edgeMode) {
    result["edgeMode"] = toDynamic(edgeMode);
  }
  return result;
}
#endif
RNSVGFeMergeProps::RNSVGFeMergeProps(
    const PropsParserContext &context,
    const RNSVGFeMergeProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    result(convertRawProp(context, rawProps, "result", sourceProps.result, {})),
    nodes(convertRawProp(context, rawProps, "nodes", sourceProps.nodes, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGFeMergeProps::getDiffPropsImplementationTarget() const {
  return "RNSVGFeMerge";
}

folly::dynamic RNSVGFeMergeProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGFeMergeProps();
  const RNSVGFeMergeProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGFeMergeProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (result != oldProps->result) {
    result["result"] = result;
  }
    
  if (nodes != oldProps->nodes) {
    result["nodes"] = toDynamic(nodes);
  }
  return result;
}
#endif
RNSVGFeOffsetProps::RNSVGFeOffsetProps(
    const PropsParserContext &context,
    const RNSVGFeOffsetProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    result(convertRawProp(context, rawProps, "result", sourceProps.result, {})),
    in1(convertRawProp(context, rawProps, "in1", sourceProps.in1, {})),
    dx(convertRawProp(context, rawProps, "dx", sourceProps.dx, {})),
    dy(convertRawProp(context, rawProps, "dy", sourceProps.dy, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGFeOffsetProps::getDiffPropsImplementationTarget() const {
  return "RNSVGFeOffset";
}

folly::dynamic RNSVGFeOffsetProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGFeOffsetProps();
  const RNSVGFeOffsetProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGFeOffsetProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (result != oldProps->result) {
    result["result"] = result;
  }
    
  if (in1 != oldProps->in1) {
    result["in1"] = in1;
  }
    
  if (dx != oldProps->dx) {
    result["dx"] = dx;
  }
    
  if (dy != oldProps->dy) {
    result["dy"] = dy;
  }
  return result;
}
#endif
RNSVGFilterProps::RNSVGFilterProps(
    const PropsParserContext &context,
    const RNSVGFilterProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    filterUnits(convertRawProp(context, rawProps, "filterUnits", sourceProps.filterUnits, {RNSVGFilterFilterUnits::ObjectBoundingBox})),
    primitiveUnits(convertRawProp(context, rawProps, "primitiveUnits", sourceProps.primitiveUnits, {RNSVGFilterPrimitiveUnits::UserSpaceOnUse})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGFilterProps::getDiffPropsImplementationTarget() const {
  return "RNSVGFilter";
}

folly::dynamic RNSVGFilterProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGFilterProps();
  const RNSVGFilterProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGFilterProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (filterUnits != oldProps->filterUnits) {
    result["filterUnits"] = toDynamic(filterUnits);
  }
    
  if (primitiveUnits != oldProps->primitiveUnits) {
    result["primitiveUnits"] = toDynamic(primitiveUnits);
  }
  return result;
}
#endif
RNSVGForeignObjectProps::RNSVGForeignObjectProps(
    const PropsParserContext &context,
    const RNSVGForeignObjectProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGForeignObjectProps::getDiffPropsImplementationTarget() const {
  return "RNSVGForeignObject";
}

folly::dynamic RNSVGForeignObjectProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGForeignObjectProps();
  const RNSVGForeignObjectProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGForeignObjectProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
  return result;
}
#endif
RNSVGGroupProps::RNSVGGroupProps(
    const PropsParserContext &context,
    const RNSVGGroupProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGGroupProps::getDiffPropsImplementationTarget() const {
  return "RNSVGGroup";
}

folly::dynamic RNSVGGroupProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGGroupProps();
  const RNSVGGroupProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGGroupProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
  return result;
}
#endif
RNSVGImageProps::RNSVGImageProps(
    const PropsParserContext &context,
    const RNSVGImageProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    src(convertRawProp(context, rawProps, "src", sourceProps.src, {})),
    align(convertRawProp(context, rawProps, "align", sourceProps.align, {})),
    meetOrSlice(convertRawProp(context, rawProps, "meetOrSlice", sourceProps.meetOrSlice, {0})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGImageProps::getDiffPropsImplementationTarget() const {
  return "RNSVGImage";
}

folly::dynamic RNSVGImageProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGImageProps();
  const RNSVGImageProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGImageProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (src != oldProps->src) {
    result["src"] = toDynamic(src);
  }
    
  if (align != oldProps->align) {
    result["align"] = align;
  }
    
  if (meetOrSlice != oldProps->meetOrSlice) {
    result["meetOrSlice"] = meetOrSlice;
  }
  return result;
}
#endif
RNSVGSvgViewProps::RNSVGSvgViewProps(
    const PropsParserContext &context,
    const RNSVGSvgViewProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    bbWidth(convertRawProp(context, rawProps, "bbWidth", sourceProps.bbWidth, {})),
    bbHeight(convertRawProp(context, rawProps, "bbHeight", sourceProps.bbHeight, {})),
    minX(convertRawProp(context, rawProps, "minX", sourceProps.minX, {0.0})),
    minY(convertRawProp(context, rawProps, "minY", sourceProps.minY, {0.0})),
    vbWidth(convertRawProp(context, rawProps, "vbWidth", sourceProps.vbWidth, {0.0})),
    vbHeight(convertRawProp(context, rawProps, "vbHeight", sourceProps.vbHeight, {0.0})),
    align(convertRawProp(context, rawProps, "align", sourceProps.align, {})),
    meetOrSlice(convertRawProp(context, rawProps, "meetOrSlice", sourceProps.meetOrSlice, {0})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    hitSlop(convertRawProp(context, rawProps, "hitSlop", sourceProps.hitSlop, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGSvgViewProps::getDiffPropsImplementationTarget() const {
  return "RNSVGSvgView";
}

folly::dynamic RNSVGSvgViewProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGSvgViewProps();
  const RNSVGSvgViewProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGSvgViewProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (bbWidth != oldProps->bbWidth) {
    result["bbWidth"] = bbWidth;
  }
    
  if (bbHeight != oldProps->bbHeight) {
    result["bbHeight"] = bbHeight;
  }
    
  if ((minX != oldProps->minX) && !(std::isnan(minX) && std::isnan(oldProps->minX))) {
    result["minX"] = minX;
  }
    
  if ((minY != oldProps->minY) && !(std::isnan(minY) && std::isnan(oldProps->minY))) {
    result["minY"] = minY;
  }
    
  if ((vbWidth != oldProps->vbWidth) && !(std::isnan(vbWidth) && std::isnan(oldProps->vbWidth))) {
    result["vbWidth"] = vbWidth;
  }
    
  if ((vbHeight != oldProps->vbHeight) && !(std::isnan(vbHeight) && std::isnan(oldProps->vbHeight))) {
    result["vbHeight"] = vbHeight;
  }
    
  if (align != oldProps->align) {
    result["align"] = align;
  }
    
  if (meetOrSlice != oldProps->meetOrSlice) {
    result["meetOrSlice"] = meetOrSlice;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (hitSlop != oldProps->hitSlop) {
    result["hitSlop"] = hitSlop;
  }
  return result;
}
#endif
RNSVGLinearGradientProps::RNSVGLinearGradientProps(
    const PropsParserContext &context,
    const RNSVGLinearGradientProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    x1(convertRawProp(context, rawProps, "x1", sourceProps.x1, {})),
    y1(convertRawProp(context, rawProps, "y1", sourceProps.y1, {})),
    x2(convertRawProp(context, rawProps, "x2", sourceProps.x2, {})),
    y2(convertRawProp(context, rawProps, "y2", sourceProps.y2, {})),
    gradient(convertRawProp(context, rawProps, "gradient", sourceProps.gradient, {})),
    gradientUnits(convertRawProp(context, rawProps, "gradientUnits", sourceProps.gradientUnits, {0})),
    gradientTransform(convertRawProp(context, rawProps, "gradientTransform", sourceProps.gradientTransform, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGLinearGradientProps::getDiffPropsImplementationTarget() const {
  return "RNSVGLinearGradient";
}

folly::dynamic RNSVGLinearGradientProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGLinearGradientProps();
  const RNSVGLinearGradientProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGLinearGradientProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (x1 != oldProps->x1) {
    result["x1"] = x1;
  }
    
  if (y1 != oldProps->y1) {
    result["y1"] = y1;
  }
    
  if (x2 != oldProps->x2) {
    result["x2"] = x2;
  }
    
  if (y2 != oldProps->y2) {
    result["y2"] = y2;
  }
    
  if (gradient != oldProps->gradient) {
    result["gradient"] = toDynamic(gradient);
  }
    
  if (gradientUnits != oldProps->gradientUnits) {
    result["gradientUnits"] = gradientUnits;
  }
    
  if (gradientTransform != oldProps->gradientTransform) {
    result["gradientTransform"] = toDynamic(gradientTransform);
  }
  return result;
}
#endif
RNSVGLineProps::RNSVGLineProps(
    const PropsParserContext &context,
    const RNSVGLineProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    x1(convertRawProp(context, rawProps, "x1", sourceProps.x1, {})),
    y1(convertRawProp(context, rawProps, "y1", sourceProps.y1, {})),
    x2(convertRawProp(context, rawProps, "x2", sourceProps.x2, {})),
    y2(convertRawProp(context, rawProps, "y2", sourceProps.y2, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGLineProps::getDiffPropsImplementationTarget() const {
  return "RNSVGLine";
}

folly::dynamic RNSVGLineProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGLineProps();
  const RNSVGLineProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGLineProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (x1 != oldProps->x1) {
    result["x1"] = x1;
  }
    
  if (y1 != oldProps->y1) {
    result["y1"] = y1;
  }
    
  if (x2 != oldProps->x2) {
    result["x2"] = x2;
  }
    
  if (y2 != oldProps->y2) {
    result["y2"] = y2;
  }
  return result;
}
#endif
RNSVGMarkerProps::RNSVGMarkerProps(
    const PropsParserContext &context,
    const RNSVGMarkerProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})),
    refX(convertRawProp(context, rawProps, "refX", sourceProps.refX, {})),
    refY(convertRawProp(context, rawProps, "refY", sourceProps.refY, {})),
    markerHeight(convertRawProp(context, rawProps, "markerHeight", sourceProps.markerHeight, {})),
    markerWidth(convertRawProp(context, rawProps, "markerWidth", sourceProps.markerWidth, {})),
    markerUnits(convertRawProp(context, rawProps, "markerUnits", sourceProps.markerUnits, {})),
    orient(convertRawProp(context, rawProps, "orient", sourceProps.orient, {})),
    minX(convertRawProp(context, rawProps, "minX", sourceProps.minX, {0.0})),
    minY(convertRawProp(context, rawProps, "minY", sourceProps.minY, {0.0})),
    vbWidth(convertRawProp(context, rawProps, "vbWidth", sourceProps.vbWidth, {0.0})),
    vbHeight(convertRawProp(context, rawProps, "vbHeight", sourceProps.vbHeight, {0.0})),
    align(convertRawProp(context, rawProps, "align", sourceProps.align, {})),
    meetOrSlice(convertRawProp(context, rawProps, "meetOrSlice", sourceProps.meetOrSlice, {0})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGMarkerProps::getDiffPropsImplementationTarget() const {
  return "RNSVGMarker";
}

folly::dynamic RNSVGMarkerProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGMarkerProps();
  const RNSVGMarkerProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGMarkerProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
    
  if (refX != oldProps->refX) {
    result["refX"] = refX;
  }
    
  if (refY != oldProps->refY) {
    result["refY"] = refY;
  }
    
  if (markerHeight != oldProps->markerHeight) {
    result["markerHeight"] = markerHeight;
  }
    
  if (markerWidth != oldProps->markerWidth) {
    result["markerWidth"] = markerWidth;
  }
    
  if (markerUnits != oldProps->markerUnits) {
    result["markerUnits"] = markerUnits;
  }
    
  if (orient != oldProps->orient) {
    result["orient"] = orient;
  }
    
  if ((minX != oldProps->minX) && !(std::isnan(minX) && std::isnan(oldProps->minX))) {
    result["minX"] = minX;
  }
    
  if ((minY != oldProps->minY) && !(std::isnan(minY) && std::isnan(oldProps->minY))) {
    result["minY"] = minY;
  }
    
  if ((vbWidth != oldProps->vbWidth) && !(std::isnan(vbWidth) && std::isnan(oldProps->vbWidth))) {
    result["vbWidth"] = vbWidth;
  }
    
  if ((vbHeight != oldProps->vbHeight) && !(std::isnan(vbHeight) && std::isnan(oldProps->vbHeight))) {
    result["vbHeight"] = vbHeight;
  }
    
  if (align != oldProps->align) {
    result["align"] = align;
  }
    
  if (meetOrSlice != oldProps->meetOrSlice) {
    result["meetOrSlice"] = meetOrSlice;
  }
  return result;
}
#endif
RNSVGMaskProps::RNSVGMaskProps(
    const PropsParserContext &context,
    const RNSVGMaskProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    maskUnits(convertRawProp(context, rawProps, "maskUnits", sourceProps.maskUnits, {0})),
    maskContentUnits(convertRawProp(context, rawProps, "maskContentUnits", sourceProps.maskContentUnits, {0})),
    maskType(convertRawProp(context, rawProps, "maskType", sourceProps.maskType, {0})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGMaskProps::getDiffPropsImplementationTarget() const {
  return "RNSVGMask";
}

folly::dynamic RNSVGMaskProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGMaskProps();
  const RNSVGMaskProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGMaskProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (maskUnits != oldProps->maskUnits) {
    result["maskUnits"] = maskUnits;
  }
    
  if (maskContentUnits != oldProps->maskContentUnits) {
    result["maskContentUnits"] = maskContentUnits;
  }
    
  if (maskType != oldProps->maskType) {
    result["maskType"] = maskType;
  }
  return result;
}
#endif
RNSVGPathProps::RNSVGPathProps(
    const PropsParserContext &context,
    const RNSVGPathProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    d(convertRawProp(context, rawProps, "d", sourceProps.d, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGPathProps::getDiffPropsImplementationTarget() const {
  return "RNSVGPath";
}

folly::dynamic RNSVGPathProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGPathProps();
  const RNSVGPathProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGPathProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (d != oldProps->d) {
    result["d"] = d;
  }
  return result;
}
#endif
RNSVGPatternProps::RNSVGPatternProps(
    const PropsParserContext &context,
    const RNSVGPatternProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    patternUnits(convertRawProp(context, rawProps, "patternUnits", sourceProps.patternUnits, {0})),
    patternContentUnits(convertRawProp(context, rawProps, "patternContentUnits", sourceProps.patternContentUnits, {0})),
    patternTransform(convertRawProp(context, rawProps, "patternTransform", sourceProps.patternTransform, {})),
    minX(convertRawProp(context, rawProps, "minX", sourceProps.minX, {0.0})),
    minY(convertRawProp(context, rawProps, "minY", sourceProps.minY, {0.0})),
    vbWidth(convertRawProp(context, rawProps, "vbWidth", sourceProps.vbWidth, {0.0})),
    vbHeight(convertRawProp(context, rawProps, "vbHeight", sourceProps.vbHeight, {0.0})),
    align(convertRawProp(context, rawProps, "align", sourceProps.align, {})),
    meetOrSlice(convertRawProp(context, rawProps, "meetOrSlice", sourceProps.meetOrSlice, {0})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGPatternProps::getDiffPropsImplementationTarget() const {
  return "RNSVGPattern";
}

folly::dynamic RNSVGPatternProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGPatternProps();
  const RNSVGPatternProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGPatternProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (patternUnits != oldProps->patternUnits) {
    result["patternUnits"] = patternUnits;
  }
    
  if (patternContentUnits != oldProps->patternContentUnits) {
    result["patternContentUnits"] = patternContentUnits;
  }
    
  if (patternTransform != oldProps->patternTransform) {
    result["patternTransform"] = toDynamic(patternTransform);
  }
    
  if ((minX != oldProps->minX) && !(std::isnan(minX) && std::isnan(oldProps->minX))) {
    result["minX"] = minX;
  }
    
  if ((minY != oldProps->minY) && !(std::isnan(minY) && std::isnan(oldProps->minY))) {
    result["minY"] = minY;
  }
    
  if ((vbWidth != oldProps->vbWidth) && !(std::isnan(vbWidth) && std::isnan(oldProps->vbWidth))) {
    result["vbWidth"] = vbWidth;
  }
    
  if ((vbHeight != oldProps->vbHeight) && !(std::isnan(vbHeight) && std::isnan(oldProps->vbHeight))) {
    result["vbHeight"] = vbHeight;
  }
    
  if (align != oldProps->align) {
    result["align"] = align;
  }
    
  if (meetOrSlice != oldProps->meetOrSlice) {
    result["meetOrSlice"] = meetOrSlice;
  }
  return result;
}
#endif
RNSVGRadialGradientProps::RNSVGRadialGradientProps(
    const PropsParserContext &context,
    const RNSVGRadialGradientProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    fx(convertRawProp(context, rawProps, "fx", sourceProps.fx, {})),
    fy(convertRawProp(context, rawProps, "fy", sourceProps.fy, {})),
    cx(convertRawProp(context, rawProps, "cx", sourceProps.cx, {})),
    cy(convertRawProp(context, rawProps, "cy", sourceProps.cy, {})),
    rx(convertRawProp(context, rawProps, "rx", sourceProps.rx, {})),
    ry(convertRawProp(context, rawProps, "ry", sourceProps.ry, {})),
    gradient(convertRawProp(context, rawProps, "gradient", sourceProps.gradient, {})),
    gradientUnits(convertRawProp(context, rawProps, "gradientUnits", sourceProps.gradientUnits, {0})),
    gradientTransform(convertRawProp(context, rawProps, "gradientTransform", sourceProps.gradientTransform, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGRadialGradientProps::getDiffPropsImplementationTarget() const {
  return "RNSVGRadialGradient";
}

folly::dynamic RNSVGRadialGradientProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGRadialGradientProps();
  const RNSVGRadialGradientProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGRadialGradientProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (fx != oldProps->fx) {
    result["fx"] = fx;
  }
    
  if (fy != oldProps->fy) {
    result["fy"] = fy;
  }
    
  if (cx != oldProps->cx) {
    result["cx"] = cx;
  }
    
  if (cy != oldProps->cy) {
    result["cy"] = cy;
  }
    
  if (rx != oldProps->rx) {
    result["rx"] = rx;
  }
    
  if (ry != oldProps->ry) {
    result["ry"] = ry;
  }
    
  if (gradient != oldProps->gradient) {
    result["gradient"] = toDynamic(gradient);
  }
    
  if (gradientUnits != oldProps->gradientUnits) {
    result["gradientUnits"] = gradientUnits;
  }
    
  if (gradientTransform != oldProps->gradientTransform) {
    result["gradientTransform"] = toDynamic(gradientTransform);
  }
  return result;
}
#endif
RNSVGRectProps::RNSVGRectProps(
    const PropsParserContext &context,
    const RNSVGRectProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})),
    rx(convertRawProp(context, rawProps, "rx", sourceProps.rx, {})),
    ry(convertRawProp(context, rawProps, "ry", sourceProps.ry, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGRectProps::getDiffPropsImplementationTarget() const {
  return "RNSVGRect";
}

folly::dynamic RNSVGRectProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGRectProps();
  const RNSVGRectProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGRectProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
    
  if (rx != oldProps->rx) {
    result["rx"] = rx;
  }
    
  if (ry != oldProps->ry) {
    result["ry"] = ry;
  }
  return result;
}
#endif
RNSVGSymbolProps::RNSVGSymbolProps(
    const PropsParserContext &context,
    const RNSVGSymbolProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})),
    minX(convertRawProp(context, rawProps, "minX", sourceProps.minX, {0.0})),
    minY(convertRawProp(context, rawProps, "minY", sourceProps.minY, {0.0})),
    vbWidth(convertRawProp(context, rawProps, "vbWidth", sourceProps.vbWidth, {0.0})),
    vbHeight(convertRawProp(context, rawProps, "vbHeight", sourceProps.vbHeight, {0.0})),
    align(convertRawProp(context, rawProps, "align", sourceProps.align, {})),
    meetOrSlice(convertRawProp(context, rawProps, "meetOrSlice", sourceProps.meetOrSlice, {0})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGSymbolProps::getDiffPropsImplementationTarget() const {
  return "RNSVGSymbol";
}

folly::dynamic RNSVGSymbolProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGSymbolProps();
  const RNSVGSymbolProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGSymbolProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
    
  if ((minX != oldProps->minX) && !(std::isnan(minX) && std::isnan(oldProps->minX))) {
    result["minX"] = minX;
  }
    
  if ((minY != oldProps->minY) && !(std::isnan(minY) && std::isnan(oldProps->minY))) {
    result["minY"] = minY;
  }
    
  if ((vbWidth != oldProps->vbWidth) && !(std::isnan(vbWidth) && std::isnan(oldProps->vbWidth))) {
    result["vbWidth"] = vbWidth;
  }
    
  if ((vbHeight != oldProps->vbHeight) && !(std::isnan(vbHeight) && std::isnan(oldProps->vbHeight))) {
    result["vbHeight"] = vbHeight;
  }
    
  if (align != oldProps->align) {
    result["align"] = align;
  }
    
  if (meetOrSlice != oldProps->meetOrSlice) {
    result["meetOrSlice"] = meetOrSlice;
  }
  return result;
}
#endif
RNSVGTextProps::RNSVGTextProps(
    const PropsParserContext &context,
    const RNSVGTextProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})),
    dx(convertRawProp(context, rawProps, "dx", sourceProps.dx, {})),
    dy(convertRawProp(context, rawProps, "dy", sourceProps.dy, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    rotate(convertRawProp(context, rawProps, "rotate", sourceProps.rotate, {})),
    inlineSize(convertRawProp(context, rawProps, "inlineSize", sourceProps.inlineSize, {})),
    textLength(convertRawProp(context, rawProps, "textLength", sourceProps.textLength, {})),
    baselineShift(convertRawProp(context, rawProps, "baselineShift", sourceProps.baselineShift, {})),
    lengthAdjust(convertRawProp(context, rawProps, "lengthAdjust", sourceProps.lengthAdjust, {})),
    alignmentBaseline(convertRawProp(context, rawProps, "alignmentBaseline", sourceProps.alignmentBaseline, {})),
    verticalAlign(convertRawProp(context, rawProps, "verticalAlign", sourceProps.verticalAlign, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGTextProps::getDiffPropsImplementationTarget() const {
  return "RNSVGText";
}

folly::dynamic RNSVGTextProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGTextProps();
  const RNSVGTextProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGTextProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
    
  if (dx != oldProps->dx) {
    result["dx"] = dx;
  }
    
  if (dy != oldProps->dy) {
    result["dy"] = dy;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (rotate != oldProps->rotate) {
    result["rotate"] = rotate;
  }
    
  if (inlineSize != oldProps->inlineSize) {
    result["inlineSize"] = inlineSize;
  }
    
  if (textLength != oldProps->textLength) {
    result["textLength"] = textLength;
  }
    
  if (baselineShift != oldProps->baselineShift) {
    result["baselineShift"] = baselineShift;
  }
    
  if (lengthAdjust != oldProps->lengthAdjust) {
    result["lengthAdjust"] = lengthAdjust;
  }
    
  if (alignmentBaseline != oldProps->alignmentBaseline) {
    result["alignmentBaseline"] = alignmentBaseline;
  }
    
  if (verticalAlign != oldProps->verticalAlign) {
    result["verticalAlign"] = verticalAlign;
  }
  return result;
}
#endif
RNSVGTextPathProps::RNSVGTextPathProps(
    const PropsParserContext &context,
    const RNSVGTextPathProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})),
    dx(convertRawProp(context, rawProps, "dx", sourceProps.dx, {})),
    dy(convertRawProp(context, rawProps, "dy", sourceProps.dy, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    rotate(convertRawProp(context, rawProps, "rotate", sourceProps.rotate, {})),
    inlineSize(convertRawProp(context, rawProps, "inlineSize", sourceProps.inlineSize, {})),
    textLength(convertRawProp(context, rawProps, "textLength", sourceProps.textLength, {})),
    baselineShift(convertRawProp(context, rawProps, "baselineShift", sourceProps.baselineShift, {})),
    lengthAdjust(convertRawProp(context, rawProps, "lengthAdjust", sourceProps.lengthAdjust, {})),
    alignmentBaseline(convertRawProp(context, rawProps, "alignmentBaseline", sourceProps.alignmentBaseline, {})),
    verticalAlign(convertRawProp(context, rawProps, "verticalAlign", sourceProps.verticalAlign, {})),
    href(convertRawProp(context, rawProps, "href", sourceProps.href, {})),
    side(convertRawProp(context, rawProps, "side", sourceProps.side, {})),
    method(convertRawProp(context, rawProps, "method", sourceProps.method, {})),
    midLine(convertRawProp(context, rawProps, "midLine", sourceProps.midLine, {})),
    spacing(convertRawProp(context, rawProps, "spacing", sourceProps.spacing, {})),
    startOffset(convertRawProp(context, rawProps, "startOffset", sourceProps.startOffset, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGTextPathProps::getDiffPropsImplementationTarget() const {
  return "RNSVGTextPath";
}

folly::dynamic RNSVGTextPathProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGTextPathProps();
  const RNSVGTextPathProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGTextPathProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
    
  if (dx != oldProps->dx) {
    result["dx"] = dx;
  }
    
  if (dy != oldProps->dy) {
    result["dy"] = dy;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (rotate != oldProps->rotate) {
    result["rotate"] = rotate;
  }
    
  if (inlineSize != oldProps->inlineSize) {
    result["inlineSize"] = inlineSize;
  }
    
  if (textLength != oldProps->textLength) {
    result["textLength"] = textLength;
  }
    
  if (baselineShift != oldProps->baselineShift) {
    result["baselineShift"] = baselineShift;
  }
    
  if (lengthAdjust != oldProps->lengthAdjust) {
    result["lengthAdjust"] = lengthAdjust;
  }
    
  if (alignmentBaseline != oldProps->alignmentBaseline) {
    result["alignmentBaseline"] = alignmentBaseline;
  }
    
  if (verticalAlign != oldProps->verticalAlign) {
    result["verticalAlign"] = verticalAlign;
  }
    
  if (href != oldProps->href) {
    result["href"] = href;
  }
    
  if (side != oldProps->side) {
    result["side"] = side;
  }
    
  if (method != oldProps->method) {
    result["method"] = method;
  }
    
  if (midLine != oldProps->midLine) {
    result["midLine"] = midLine;
  }
    
  if (spacing != oldProps->spacing) {
    result["spacing"] = spacing;
  }
    
  if (startOffset != oldProps->startOffset) {
    result["startOffset"] = startOffset;
  }
  return result;
}
#endif
RNSVGTSpanProps::RNSVGTSpanProps(
    const PropsParserContext &context,
    const RNSVGTSpanProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    fontSize(convertRawProp(context, rawProps, "fontSize", sourceProps.fontSize, {})),
    fontWeight(convertRawProp(context, rawProps, "fontWeight", sourceProps.fontWeight, {})),
    font(convertRawProp(context, rawProps, "font", sourceProps.font, {})),
    dx(convertRawProp(context, rawProps, "dx", sourceProps.dx, {})),
    dy(convertRawProp(context, rawProps, "dy", sourceProps.dy, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    rotate(convertRawProp(context, rawProps, "rotate", sourceProps.rotate, {})),
    inlineSize(convertRawProp(context, rawProps, "inlineSize", sourceProps.inlineSize, {})),
    textLength(convertRawProp(context, rawProps, "textLength", sourceProps.textLength, {})),
    baselineShift(convertRawProp(context, rawProps, "baselineShift", sourceProps.baselineShift, {})),
    lengthAdjust(convertRawProp(context, rawProps, "lengthAdjust", sourceProps.lengthAdjust, {})),
    alignmentBaseline(convertRawProp(context, rawProps, "alignmentBaseline", sourceProps.alignmentBaseline, {})),
    verticalAlign(convertRawProp(context, rawProps, "verticalAlign", sourceProps.verticalAlign, {})),
    content(convertRawProp(context, rawProps, "content", sourceProps.content, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGTSpanProps::getDiffPropsImplementationTarget() const {
  return "RNSVGTSpan";
}

folly::dynamic RNSVGTSpanProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGTSpanProps();
  const RNSVGTSpanProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGTSpanProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (fontSize != oldProps->fontSize) {
    result["fontSize"] = fontSize;
  }
    
  if (fontWeight != oldProps->fontWeight) {
    result["fontWeight"] = fontWeight;
  }
    
  if (font != oldProps->font) {
    result["font"] = font;
  }
    
  if (dx != oldProps->dx) {
    result["dx"] = dx;
  }
    
  if (dy != oldProps->dy) {
    result["dy"] = dy;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (rotate != oldProps->rotate) {
    result["rotate"] = rotate;
  }
    
  if (inlineSize != oldProps->inlineSize) {
    result["inlineSize"] = inlineSize;
  }
    
  if (textLength != oldProps->textLength) {
    result["textLength"] = textLength;
  }
    
  if (baselineShift != oldProps->baselineShift) {
    result["baselineShift"] = baselineShift;
  }
    
  if (lengthAdjust != oldProps->lengthAdjust) {
    result["lengthAdjust"] = lengthAdjust;
  }
    
  if (alignmentBaseline != oldProps->alignmentBaseline) {
    result["alignmentBaseline"] = alignmentBaseline;
  }
    
  if (verticalAlign != oldProps->verticalAlign) {
    result["verticalAlign"] = verticalAlign;
  }
    
  if (content != oldProps->content) {
    result["content"] = content;
  }
  return result;
}
#endif
RNSVGUseProps::RNSVGUseProps(
    const PropsParserContext &context,
    const RNSVGUseProps &sourceProps,
    const RawProps &rawProps): ViewProps(context, sourceProps, rawProps),

    name(convertRawProp(context, rawProps, "name", sourceProps.name, {})),
    opacity(convertRawProp(context, rawProps, "opacity", sourceProps.opacity, {1.0})),
    matrix(convertRawProp(context, rawProps, "matrix", sourceProps.matrix, {})),
    mask(convertRawProp(context, rawProps, "mask", sourceProps.mask, {})),
    markerStart(convertRawProp(context, rawProps, "markerStart", sourceProps.markerStart, {})),
    markerMid(convertRawProp(context, rawProps, "markerMid", sourceProps.markerMid, {})),
    markerEnd(convertRawProp(context, rawProps, "markerEnd", sourceProps.markerEnd, {})),
    clipPath(convertRawProp(context, rawProps, "clipPath", sourceProps.clipPath, {})),
    clipRule(convertRawProp(context, rawProps, "clipRule", sourceProps.clipRule, {0})),
    responsible(convertRawProp(context, rawProps, "responsible", sourceProps.responsible, {false})),
    display(convertRawProp(context, rawProps, "display", sourceProps.display, {})),
    pointerEvents(convertRawProp(context, rawProps, "pointerEvents", sourceProps.pointerEvents, {})),
    color(convertRawProp(context, rawProps, "color", sourceProps.color, {})),
    fill(convertRawProp(context, rawProps, "fill", sourceProps.fill, {})),
    fillOpacity(convertRawProp(context, rawProps, "fillOpacity", sourceProps.fillOpacity, {1.0})),
    fillRule(convertRawProp(context, rawProps, "fillRule", sourceProps.fillRule, {1})),
    stroke(convertRawProp(context, rawProps, "stroke", sourceProps.stroke, {})),
    strokeOpacity(convertRawProp(context, rawProps, "strokeOpacity", sourceProps.strokeOpacity, {1.0})),
    strokeWidth(convertRawProp(context, rawProps, "strokeWidth", sourceProps.strokeWidth, {})),
    strokeLinecap(convertRawProp(context, rawProps, "strokeLinecap", sourceProps.strokeLinecap, {0})),
    strokeLinejoin(convertRawProp(context, rawProps, "strokeLinejoin", sourceProps.strokeLinejoin, {0})),
    strokeDasharray(convertRawProp(context, rawProps, "strokeDasharray", sourceProps.strokeDasharray, {})),
    strokeDashoffset(convertRawProp(context, rawProps, "strokeDashoffset", sourceProps.strokeDashoffset, {0.0})),
    strokeMiterlimit(convertRawProp(context, rawProps, "strokeMiterlimit", sourceProps.strokeMiterlimit, {0.0})),
    vectorEffect(convertRawProp(context, rawProps, "vectorEffect", sourceProps.vectorEffect, {0})),
    propList(convertRawProp(context, rawProps, "propList", sourceProps.propList, {})),
    filter(convertRawProp(context, rawProps, "filter", sourceProps.filter, {})),
    href(convertRawProp(context, rawProps, "href", sourceProps.href, {})),
    x(convertRawProp(context, rawProps, "x", sourceProps.x, {})),
    y(convertRawProp(context, rawProps, "y", sourceProps.y, {})),
    height(convertRawProp(context, rawProps, "height", sourceProps.height, {})),
    width(convertRawProp(context, rawProps, "width", sourceProps.width, {})) {}
    
#ifdef RN_SERIALIZABLE_STATE
ComponentName RNSVGUseProps::getDiffPropsImplementationTarget() const {
  return "RNSVGUse";
}

folly::dynamic RNSVGUseProps::getDiffProps(
    const Props* prevProps) const {
  static const auto defaultProps = RNSVGUseProps();
  const RNSVGUseProps* oldProps = prevProps == nullptr
      ? &defaultProps
      : static_cast<const RNSVGUseProps*>(prevProps);
  if (this == oldProps) {
    return folly::dynamic::object();
  }
  folly::dynamic result = HostPlatformViewProps::getDiffProps(prevProps);
  
  if (name != oldProps->name) {
    result["name"] = name;
  }
    
  if ((opacity != oldProps->opacity) && !(std::isnan(opacity) && std::isnan(oldProps->opacity))) {
    result["opacity"] = opacity;
  }
    
  if (matrix != oldProps->matrix) {
    result["matrix"] = toDynamic(matrix);
  }
    
  if (mask != oldProps->mask) {
    result["mask"] = mask;
  }
    
  if (markerStart != oldProps->markerStart) {
    result["markerStart"] = markerStart;
  }
    
  if (markerMid != oldProps->markerMid) {
    result["markerMid"] = markerMid;
  }
    
  if (markerEnd != oldProps->markerEnd) {
    result["markerEnd"] = markerEnd;
  }
    
  if (clipPath != oldProps->clipPath) {
    result["clipPath"] = clipPath;
  }
    
  if (clipRule != oldProps->clipRule) {
    result["clipRule"] = clipRule;
  }
    
  if (responsible != oldProps->responsible) {
    result["responsible"] = responsible;
  }
    
  if (display != oldProps->display) {
    result["display"] = display;
  }
    
  if (pointerEvents != oldProps->pointerEvents) {
    result["pointerEvents"] = pointerEvents;
  }
    
  if (color != oldProps->color) {
    result["color"] = *color;
  }
    
  if (fill != oldProps->fill) {
    result["fill"] = fill;
  }
    
  if ((fillOpacity != oldProps->fillOpacity) && !(std::isnan(fillOpacity) && std::isnan(oldProps->fillOpacity))) {
    result["fillOpacity"] = fillOpacity;
  }
    
  if (fillRule != oldProps->fillRule) {
    result["fillRule"] = fillRule;
  }
    
  if (stroke != oldProps->stroke) {
    result["stroke"] = stroke;
  }
    
  if ((strokeOpacity != oldProps->strokeOpacity) && !(std::isnan(strokeOpacity) && std::isnan(oldProps->strokeOpacity))) {
    result["strokeOpacity"] = strokeOpacity;
  }
    
  if (strokeWidth != oldProps->strokeWidth) {
    result["strokeWidth"] = strokeWidth;
  }
    
  if (strokeLinecap != oldProps->strokeLinecap) {
    result["strokeLinecap"] = strokeLinecap;
  }
    
  if (strokeLinejoin != oldProps->strokeLinejoin) {
    result["strokeLinejoin"] = strokeLinejoin;
  }
    
  if (strokeDasharray != oldProps->strokeDasharray) {
    result["strokeDasharray"] = strokeDasharray;
  }
    
  if ((strokeDashoffset != oldProps->strokeDashoffset) && !(std::isnan(strokeDashoffset) && std::isnan(oldProps->strokeDashoffset))) {
    result["strokeDashoffset"] = strokeDashoffset;
  }
    
  if ((strokeMiterlimit != oldProps->strokeMiterlimit) && !(std::isnan(strokeMiterlimit) && std::isnan(oldProps->strokeMiterlimit))) {
    result["strokeMiterlimit"] = strokeMiterlimit;
  }
    
  if (vectorEffect != oldProps->vectorEffect) {
    result["vectorEffect"] = vectorEffect;
  }
    
  if (propList != oldProps->propList) {
    result["propList"] = toDynamic(propList);
  }
    
  if (filter != oldProps->filter) {
    result["filter"] = filter;
  }
    
  if (href != oldProps->href) {
    result["href"] = href;
  }
    
  if (x != oldProps->x) {
    result["x"] = x;
  }
    
  if (y != oldProps->y) {
    result["y"] = y;
  }
    
  if (height != oldProps->height) {
    result["height"] = height;
  }
    
  if (width != oldProps->width) {
    result["width"] = width;
  }
  return result;
}
#endif

} // namespace facebook::react
